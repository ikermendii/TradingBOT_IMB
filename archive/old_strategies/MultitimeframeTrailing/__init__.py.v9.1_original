"""
üöÄ ADVANCED TRADING STRATEGY - Multi-Timeframe Confluence + Divergences + FVG
==============================================================================

Version: 9.1-TP1 - BREAK-EVEN M√ÅS TARD√çO (1.0R‚Üí1.25R)

EVOLUCI√ìN COMPLETA DEL PROYECTO:
- v6.9: 972 trades, 24.18% WR, -30% return
- v7.0-v7.3: 0 trades ‚ùå (multi-timeframe bloque√≥ todo)
- v7.4-MINIMAL: 783 trades, 19.54% WR, -33% return, DD -69% ‚ùå (overtrading masivo)
- v7.5-QUALITY: 28 trades, 14.29% WR, -11% return, DD -15% ‚úÖ (muy restrictivo)
- v7.6-BALANCED: 803 trades, 17.06% WR, -85% return, DD -85% ‚ùå‚ùå‚ùå CATASTR√ìFICO
- v8.0-CONFLUENCE: 0 trades ‚ùå (4 filtros muy estrictos, divergencias + FVG raros)
- v8.1-ADAPTIVE: 0 trades ‚ùå (EMA200 4H bloque√≥ todo en mercado vol√°til BTC)

DIAGN√ìSTICO CR√çTICO - POR QU√â TODAS LAS VERSIONES FALLARON:
El problema NO son los par√°metros, es el ENFOQUE FUNDAMENTAL COMPLETO.
- Win/Loss Ratio: Consistente 3.5-3.9 (EXCELENTE) ‚úÖ
- Win Rate: Consistente 14-24% (TERRIBLE) ‚ùå
- 666 losses vs 137 wins (v7.6) = sistema de SELECCI√ìN DE ENTRADAS completamente roto
- Matem√°tica: (0.17 √ó 170) - (0.83 √ó 48) = 28.9 - 39.84 = -10.94 P√âRDIDA por trade

ROOT CAUSE: Estaba haciendo PRUEBA-ERROR en vez de usar:
1. Experiencia del usuario (4 a√±os trading real)
2. Investigaci√≥n profesional de internet
3. Funciones de divergencia YA PROGRAMADAS pero NUNCA USADAS
4. Proyectos exitosos de GitHub

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
ESTRATEGIA v8.6-FINAL - OPTIMIZACI√ìN FINA DEL SISTEMA DE PESOS:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

RESULTADOS COMPLETOS v8.2-v8.5:
v8.2 (score=2, sin pesos): 653 trades, 18.53% WR, -49.86%, -67.61% DD ‚Üí OVERTRADING
v8.3 (score=3, sin pesos): 550 trades, 18.18% WR, -66.03%, -74.28% DD ‚Üí PEOR
v8.4 (solo divergencias/FVG): 0 trades ‚Üí BLOQUEADO TOTAL
v8.5 (pesos, score=3): 414 trades, 19.57% WR, -3.6%, -39.19% DD, R:R 4.07 ‚Üí MEJOR ‚úÖ

BREAKTHROUGH v8.5-HYBRID:
- Win rate mejor√≥: 19.57% (vs 18.53%)
- Profit DRAM√ÅTICAMENTE mejor: -3.6% (vs -49.86%)
- Drawdown reducido: -39.19% (vs -67.61%)
- R:R excelente: 4.07 (mejor de todas las versiones)
- Comisiones reducidas: $2,869 (vs $4,981, -42%)

AN√ÅLISIS MATEM√ÅTICO:
Break-even WR necesario = 1 / (1 + R:R) = 1 / (1 + 4.07) = 19.7%
WR actual v8.5 = 19.57%
DISTANCIA AL BREAK-EVEN = solo 0.13% ‚Üê CASI RENTABLE

CAMBIOS v8.6-FINAL (ajustes m√≠nimos para cruzar break-even):
1. Cooldown: 60 min ‚Üí 45 min (permitir ~10% m√°s oportunidades)
2. Volatilidad: 0.4% ‚Üí 0.35% (permitir m√°s trades en momentos v√°lidos)
3. MANTENER sistema de pesos (ha demostrado funcionar)

SCORE SYSTEM CON PESOS (sin cambios):
- Divergencia RSI 1H = 2 PUNTOS (se√±al fuerte)
- Fair Value Gap 15M = 2 PUNTOS (se√±al fuerte)
- MACD 1H = 1 PUNTO (se√±al base)
- RSI 15M (<40 / >60) = 1 PUNTO (se√±al base)
- MACD 15M = 1 PUNTO (se√±al base)
Score m√≠nimo: 3 puntos

OBJETIVO v8.6-FINAL:
- Trades: 450-500 (10% m√°s que v8.5)
- Win Rate: 20.5-22% (superar break-even de 19.7%)
- Net profit: >0% (rentable)
- Max Drawdown: <35%
- R:R: mantener >4.0

RAZ√ìN DEL CAMBIO:
Estamos a solo 0.13% del break-even. Peque√±os ajustes en filtros secundarios
(cooldown, volatilidad) pueden generar suficientes trades extra de calidad para
cruzar el umbral de rentabilidad sin comprometer la selecci√≥n.
"""

from jesse.strategies import Strategy
import jesse.indicators as ta
import numpy as np


class Multitimeframe(Strategy):
    def __init__(self):
        super().__init__()
        self.vars = {
            'position_size': 0,
            'entry_price': 0,
            'sl_price': 0,
            'tp1_hit': False,
            'tp2_hit': False,
            'divergence_lookback': 15,
            'last_signal_time': 0,
            'daily_start_balance': 0,
            'daily_loss_check_day': None,
            # initial_risk_distance stores the price distance (in price units)
            # between entry and initial stop at the moment of entry. Use
            # this for R-based calculations so moving the stop to
            # break-even doesn't zero-out the denominator.
            'initial_risk_distance': 0,
            'trend_strength': 0,
        }

    # =============================================================================
    # C√ÅLCULO MANUAL DE RSI (para evitar IndexError con ta.rsi)
    # =============================================================================

    def _calculate_rsi_array(self, prices, period=14):
        """
        Calcula RSI manualmente para obtener un array completo de valores RSI.

        Esto evita el problema de que ta.rsi() retorne un escalar en algunos contextos.

        Args:
            prices: Array de precios (close prices)
            period: Periodo RSI (default 14)

        Returns:
            Array numpy con valores RSI para cada vela
        """
        if len(prices) < period + 1:
            return np.full(len(prices), 50.0)  # RSI neutro si no hay suficientes datos

        # Calcular cambios de precio (deltas)
        deltas = np.diff(prices)

        # Separar ganancias y p√©rdidas
        gains = np.where(deltas > 0, deltas, 0)
        losses = np.where(deltas < 0, -deltas, 0)

        # Inicializar arrays para promedios
        avg_gains = np.zeros(len(prices))
        avg_losses = np.zeros(len(prices))

        # Calcular primera media simple (SMA)
        avg_gains[period] = np.mean(gains[:period])
        avg_losses[period] = np.mean(losses[:period])

        # Calcular resto usando EMA (Wilder's smoothing)
        for i in range(period + 1, len(prices)):
            avg_gains[i] = (avg_gains[i-1] * (period - 1) + gains[i-1]) / period
            avg_losses[i] = (avg_losses[i-1] * (period - 1) + losses[i-1]) / period

        # Calcular RS (Relative Strength)
        # Evitar divisi√≥n por cero agregando epsilon
        rs = avg_gains / (avg_losses + 1e-10)

        # Calcular RSI
        rsi = 100 - (100 / (1 + rs))

        # Primeras 'period' velas tienen RSI neutro (50)
        rsi[:period] = 50.0

        return rsi

    # =============================================================================
    # PAR√ÅMETROS DE LA ESTRATEGIA
    # =============================================================================

    @property
    def rsi_period(self):
        return 14

    @property
    def macd_fast(self):
        # v6.0-PRO: MACD m√°s sensible para crypto (15, 30, 9)
        return 15

    @property
    def macd_slow(self):
        # v6.0-PRO: MACD m√°s sensible para crypto (15, 30, 9)
        return 30

    @property
    def macd_signal(self):
        return 9

    @property
    def ema_fast(self):
        return 50

    @property
    def ema_slow(self):
        return 200

    @property
    def atr_period(self):
        return 14

    @property
    def volume_period(self):
        return 20

    @property
    def risk_percent(self):
        return 1.5  # 1.5% risk per trade


    # -- New tunables to control selectivity and reduce overtrading --
    @property
    def signal_cooldown_minutes(self):
        # v9.0-MICRO: Volver a 60 min (v8.5 original, cooldown no tuvo efecto)
        return 60

    @property
    def rsi_long_threshold(self):
        # v9.0-MICRO: RSI 38 (permite entradas ligeramente m√°s tempranas)
        return 38

    @property
    def rsi_short_threshold(self):
        # v9.0-MICRO: RSI 62 (simetr√≠a con LONG, permite entradas m√°s tempranas)
        return 62

    @property
    def minimum_score(self):
        # v8.5-HYBRID: Score m√≠nimo 3 puntos CON sistema de pesos
        return 3

    @property
    def fvg_lookback(self):
        # v8.0-CONFLUENCE: Velas a revisar para detectar Fair Value Gaps
        return 20

    @property
    def min_atr_pct(self):
        # v8.9-FINAL: Volver exactamente a v8.5
        return 0.004  # 0.4% - igual que v8.5

    @property
    def max_atr_pct(self):
        # v8.6-PROFESSIONAL: Volatilidad m√°xima (nuevo, evitar extrema volatilidad)
        return 0.025  # 2.5% - evitar liquidaciones masivas

    @property
    def adx_threshold(self):
        # v8.6-PROFESSIONAL: ADX threshold RELAJADO (investigaci√≥n GitHub: 15-18)
        return 15  # MUY relajado, solo evita mercados completamente planos

    @property
    def minimum_rr_ratio(self):
        # v8.6-PROFESSIONAL: R:R m√≠nimo requerido antes de abrir trade
        return 2.0  # M√≠nimo 2R disponible (FreqTrade/Hummingbot standard)

    @property
    def require_volume(self):
        # Require positive volume confirmation
        return True

    @property
    def max_daily_loss_pct(self):
        """P√©rdida m√°xima permitida por d√≠a (% del capital inicial del d√≠a)"""
        return 3.0  # 3% de p√©rdida m√°xima diaria

    @property
    def leverage(self):
        """Apalancamiento para futuros (20x)"""
        return 20

    @property
    def minimum_rr_ratio(self):
        """Risk:Reward m√≠nimo requerido - REGLA PROFESIONAL"""
        return 2.0  # M√≠nimo 2R disponible para abrir trade

    # =============================================================================
    # CONDICIONES DE ENTRADA
    # =============================================================================

    def _is_trending_market_4h(self) -> bool:
        """
        v6.1-BALANCED: Filtro ADX en 4H M√ÅS PERMISIVO para evitar solo mercados muy laterales

        ADX > 20 = Mercado con algo de tendencia (tradeable) - RELAJADO
        ADX < 20 = Mercado muy lateral (evitar)

        Returns:
            True si el mercado 4H est√° en tendencia (ADX > 20)
        """
        try:
            # Obtener velas 4H desde extra_candles
            candles_4h = self.get_candles('Binance Perpetual Futures', 'BTC-USDT', '4h')

            if len(candles_4h) < 30:
                return False  # No hay suficientes datos

            # Calcular ADX en 4H
            adx_4h = ta.adx(candles_4h, period=14)

            # ADX > 20 = trending market (RELAJADO de 25 a 20)
            return adx_4h > self.adx_threshold

        except Exception:
            # Si hay error accediendo a 4H, ser conservador y rechazar
            return False

    def _get_trend_direction_4h(self) -> str:
        """
        v6.1-BALANCED: Determinar direcci√≥n de tendencia en 4H usando EMAs
        
        IMPORTANTE: Zona neutral amplia (1% buffer) para ser m√°s flexible

        Returns:
            'bullish': EMA50 > EMA200 + 1% buffer (tendencia alcista clara)
            'bearish': EMA50 < EMA200 - 1% buffer (tendencia bajista clara)
            'neutral': Dentro del buffer (sin tendencia clara)
        """
        try:
            candles_4h = self.get_candles('Binance Perpetual Futures', 'BTC-USDT', '4h')

            if len(candles_4h) < 200:
                return 'neutral'

            ema_50_4h = ta.ema(candles_4h, 50)
            ema_200_4h = ta.ema(candles_4h, 200)

            # Buffer del 1% para zona neutral
            diff_pct = ((ema_50_4h - ema_200_4h) / ema_200_4h) * 100

            if diff_pct > 1.0:
                return 'bullish'
            elif diff_pct < -1.0:
                return 'bearish'
            else:
                return 'neutral'

        except Exception:
            return 'neutral'

    def should_long(self) -> bool:
        """
        v8.8-OPTIMIZED: Volver a v8.5 (que funcion√≥) + mejoras selectas de GitHub

        LECCIONES APRENDIDAS:
        - v8.5: 414 trades, -3.6%, 19.57% WR (SIN filtro HTF) ‚úÖ MEJOR RESULTADO
        - v8.6/v8.7: 0 trades (CON filtro ADX 4H>15) ‚ùå BLOQUE√ì TODO

        CAMBIOS v8.8:
        1. ‚ùå ELIMINADO filtro ADX 4H (bloqueaba todo)
        2. ‚ùå ELIMINADO m√°ximo volatilidad (innecesario)
        3. ‚úÖ MANTENER sistema de pesos v8.5
        4. ‚úÖ MEJORAR MACD 1H = 2 puntos (de v8.6)
        5. ‚úÖ REDUCIR volatilidad m√≠nima 0.4% ‚Üí 0.35%
        """
        # ======= CAPA 1: FILTROS DE MERCADO (OBLIGATORIOS) =======

        # Cooldown
        if self.current_candle[0] - self.vars['last_signal_time'] < self.signal_cooldown_minutes * 60 * 1000:
            return False

        # Daily loss limit
        if not self._can_trade_today():
            return False

        # Volatilidad m√≠nima (SIN m√°ximo)
        atr = ta.atr(self.candles, 14)
        atr_pct = atr / self.close
        if atr_pct < self.min_atr_pct:
            return False

        # ======= CAPA 2: SCORE DE SE√ëALES (FLEXIBLE) =======

        score = 0

        # INDICADORES 15M
        current_rsi = ta.rsi(self.candles, 14)
        macd_15m, signal_15m_line, _ = ta.macd(self.candles, 15, 30, 9)

        # RSI oversold 15M = +1 punto
        if current_rsi < self.rsi_long_threshold:
            score += 1

        # MACD alcista 15M = +1 punto
        if macd_15m > signal_15m_line:
            score += 1

        # FVG alcista = +2 puntos (SE√ëAL PREMIUM)
        if self._detect_bullish_fvg():
            score += 2

        # INDICADORES 1H
        try:
            candles_1h = self.get_candles(self.exchange, self.symbol, '1h')
            if len(candles_1h) >= 100:
                macd_1h, signal_1h_line, _ = ta.macd(candles_1h, 15, 30, 9)

                # MACD alcista 1H = +1 punto (v8.5 original)
                if macd_1h > signal_1h_line:
                    score += 1

                # Divergencia alcista 1H = +2 puntos (SE√ëAL PREMIUM)
                if self._bullish_divergence_1h(candles_1h):
                    score += 2
        except Exception:
            pass

        # ======= CAPA 3: VALIDACI√ìN DE CALIDAD (OBLIGATORIA) =======

        # No entrar si RSI est√° en zona SHORT
        if current_rsi > self.rsi_short_threshold:
            return False

        # v8.8-OPTIMIZED: Requisito simple (como v8.5)
        # Score m√≠nimo 3 puntos (sin distinci√≥n premium/no-premium)
        if score < self.minimum_score:
            return False

        # Score alcanzado - trade v√°lido
        return True

    def should_short(self) -> bool:
        """
        v8.8-OPTIMIZED: Volver a v8.5 (que funcion√≥) + mejoras selectas de GitHub
        (Mismos cambios que should_long)
        """
        # ======= CAPA 1: FILTROS DE MERCADO (OBLIGATORIOS) =======

        # Cooldown
        if self.current_candle[0] - self.vars['last_signal_time'] < self.signal_cooldown_minutes * 60 * 1000:
            return False

        # Daily loss limit
        if not self._can_trade_today():
            return False

        # Volatilidad m√≠nima (SIN m√°ximo)
        atr = ta.atr(self.candles, 14)
        atr_pct = atr / self.close
        if atr_pct < self.min_atr_pct:
            return False

        # ======= CAPA 2: SCORE DE SE√ëALES (FLEXIBLE) =======

        score = 0

        # INDICADORES 15M
        current_rsi = ta.rsi(self.candles, 14)
        macd_15m, signal_15m_line, _ = ta.macd(self.candles, 15, 30, 9)

        # RSI overbought 15M = +1 punto
        if current_rsi > self.rsi_short_threshold:
            score += 1

        # MACD bajista 15M = +1 punto
        if macd_15m < signal_15m_line:
            score += 1

        # FVG bajista = +2 puntos (SE√ëAL PREMIUM)
        if self._detect_bearish_fvg():
            score += 2

        # INDICADORES 1H
        try:
            candles_1h = self.get_candles(self.exchange, self.symbol, '1h')
            if len(candles_1h) >= 100:
                macd_1h, signal_1h_line, _ = ta.macd(candles_1h, 15, 30, 9)

                # MACD bajista 1H = +1 punto (v8.5 original)
                if macd_1h < signal_1h_line:
                    score += 1

                # Divergencia bajista 1H = +2 puntos (SE√ëAL PREMIUM)
                if self._bearish_divergence_1h(candles_1h):
                    score += 2
        except Exception:
            pass

        # ======= CAPA 3: VALIDACI√ìN DE CALIDAD (OBLIGATORIA) =======

        # No entrar si RSI est√° en zona LONG
        if current_rsi < self.rsi_long_threshold:
            return False

        # v8.8-OPTIMIZED: Requisito simple (como v8.5)
        # Score m√≠nimo 3 puntos (sin distinci√≥n premium/no-premium)
        if score < self.minimum_score:
            return False

        # Score alcanzado - trade v√°lido
        return True

    def should_cancel_entry(self) -> bool:
        return False

    # =============================================================================
    # EJECUCI√ìN DE TRADES
    # =============================================================================

    def go_long(self):
        """Ejecutar entrada LONG en FUTURES"""
        # Calcular tama√±o de posici√≥n basado en ATR
        atr = ta.atr(self.candles, self.atr_period)
        stop_distance = atr * 3.5  # v6.9: SL AMPLIO para crypto vol√°til (era 1.8)
        qty = self._calculate_position_size(stop_distance)
        
        self.buy = qty, self.close
        
        # Registrar entrada
        self.vars['entry_price'] = self.close
        self.vars['sl_price'] = self.close - stop_distance
        self.vars['tp1_hit'] = False
        self.vars['tp2_hit'] = False
        # Store the initial risk distance (price units) to compute R
        self.vars['initial_risk_distance'] = stop_distance
        self.vars['last_signal_time'] = self.current_candle[0]
        
        # Stop loss inicial (soportado en FUTURES)
        self.stop_loss = qty, self.vars['sl_price']

    def go_short(self):
        """Ejecutar entrada SHORT en FUTURES"""
        # Calcular tama√±o de posici√≥n basado en ATR
        atr = ta.atr(self.candles, self.atr_period)
        stop_distance = atr * 3.5  # v6.9: SL AMPLIO para crypto vol√°til (era 1.8)
        qty = self._calculate_position_size(stop_distance)
        
        self.sell = qty, self.close
        
        # Registrar entrada
        self.vars['entry_price'] = self.close
        self.vars['sl_price'] = self.close + stop_distance
        self.vars['tp1_hit'] = False
        self.vars['tp2_hit'] = False
        # Store the initial risk distance (price units) to compute R
        self.vars['initial_risk_distance'] = stop_distance
        self.vars['last_signal_time'] = self.current_candle[0]
        
        # Stop loss inicial (soportado en FUTURES)
        self.stop_loss = qty, self.vars['sl_price']

    # GESTI√ìN DE POSICI√ìN
    # =============================================================================

    def update_position(self):
        """
        v7.0-PRO: Gesti√≥n PROFESIONAL simplificada

        - Break-even a 1R (proteger capital)
        - TP fijo en 3R (R:R 1:3)
        - Sin TPs intermedios (evitar cierres prematuros)
        """
        if not self.position.is_open:
            return

        initial_risk = self.vars.get('initial_risk_distance', 0)
        if initial_risk <= 0:
            return

        if self.is_long:
            current_profit = self.close - self.vars['entry_price']

            # Stop loss manual
            if self.close <= self.vars['sl_price']:
                self.liquidate()
                return
        else:
            current_profit = self.vars['entry_price'] - self.close

            if self.close >= self.vars['sl_price']:
                self.liquidate()
                return

        # Calcular R ratio
        r_ratio = current_profit / initial_risk

        # v9.1-TP1: Break-even a 1.25R (dar m√°s espacio antes de proteger)
        if r_ratio >= 1.25 and not self.vars['tp1_hit']:
            self.vars['tp1_hit'] = True
            # Mover SL a break-even
            self.vars['sl_price'] = self.vars['entry_price']

        # REGLA 2: TP completo en 3R (objetivo profesional 1:3)
        if r_ratio >= 3.0:
            self.liquidate()  # Cerrar TODO en 3R
            return

    # FILTROS DE TENDENCIA
    # =============================================================================

    def _trend_filter_long(self) -> bool:
        """Filtro de tendencia alcista: precio y EMA50 por encima de EMA200"""
        ema_50 = ta.ema(self.candles, self.ema_fast)
        ema_200 = ta.ema(self.candles, self.ema_slow)
        price_above = self.close > ema_200
        return price_above and (ema_50 > ema_200)

    def _trend_filter_short(self) -> bool:
        """Filtro de tendencia bajista: precio y EMA50 por debajo de EMA200"""
        ema_200 = ta.ema(self.candles, self.ema_slow)
        ema_50 = ta.ema(self.candles, self.ema_fast)
        price_below = self.close < ema_200
        return price_below and (ema_50 < ema_200)

    # =============================================================================
    # INDICADORES Y SE√ëALES
    # =============================================================================

    def _rsi_oversold(self) -> bool:
        """RSI en zona de sobreventa"""
        rsi = ta.rsi(self.candles[:, 2], self.rsi_period)
        return rsi < self.rsi_long_threshold

    def _rsi_overbought(self) -> bool:
        """RSI en zona de sobrecompra"""
        rsi = ta.rsi(self.candles[:, 2], self.rsi_period)
        return rsi > self.rsi_short_threshold

    def _macd_bullish_signal(self) -> bool:
        """MACD se√±al alcista simplificada"""
        macd_line, macd_signal, macd_histogram = ta.macd(self.candles[:, 2], self.macd_fast, self.macd_slow, self.macd_signal)

        # MACD es alcista (l√≠nea por encima de se√±al)
        return macd_line > macd_signal and macd_histogram > 0

    def _macd_bearish_signal(self) -> bool:
        """MACD se√±al bajista simplificada"""
        macd_line, macd_signal, macd_histogram = ta.macd(self.candles[:, 2], self.macd_fast, self.macd_slow, self.macd_signal)

        # MACD es bajista (l√≠nea por debajo de se√±al)
        return macd_line < macd_signal and macd_histogram < 0

    def _volume_confirmation(self) -> bool:
        """Confirmaci√≥n por volumen mejorada"""
        if len(self.candles) < self.volume_period:
            return False
            
        # Volumen actual vs promedio de 20 per√≠odos
        avg_volume = np.mean(self.candles[-self.volume_period:, 5])
        current_volume = self.candles[-1, 5]
        
        # Volumen de las √∫ltimas 3 velas vs promedio
        recent_volume = np.mean(self.candles[-3:, 5])
        
        return current_volume > avg_volume * 1.2 and recent_volume > avg_volume * 1.1

    def _not_overextended(self) -> bool:
        """Verificar que el precio no est√© sobreextendido"""
        ema_50 = ta.ema(self.candles, self.ema_fast)
        
        # Distancia del precio a la EMA 50
        distance_pct = abs(self.close - ema_50) / ema_50 * 100
        
        return distance_pct < 8.0  # No m√°s de 8% de distancia

    def _volatility_ok(self) -> bool:
        """Exigir volatilidad m√≠nima v√≠a ATR"""
        atr = ta.atr(self.candles, self.atr_period)
        if atr <= 0:
            return False
        return (atr / max(self.close, 1e-8)) >= self.min_atr_pct

    # =============================================================================
    # TRADE LIMITING
    # =============================================================================
    def _can_trade_today(self) -> bool:
        """Verifica si no se ha superado la p√©rdida m√°xima diaria (3%)"""
        # Calcular d√≠a usando timestamp en milisegundos
        day_key = int(self.current_candle[0] // (24 * 60 * 60 * 1000))
        last_day = self.vars.get('daily_loss_check_day', None)

        # Nuevo d√≠a: resetear balance inicial
        if last_day != day_key:
            self.vars['daily_loss_check_day'] = day_key
            self.vars['daily_start_balance'] = self.balance

        # Calcular p√©rdida del d√≠a
        daily_start = self.vars.get('daily_start_balance', self.balance)
        if daily_start <= 0:
            return True  # Caso defensivo

        current_balance = self.balance
        daily_loss_pct = ((daily_start - current_balance) / daily_start) * 100

        # Permitir trading si no se ha superado el l√≠mite de 3%
        return daily_loss_pct < self.max_daily_loss_pct

    # =============================================================================
    # DETECCI√ìN DE FAIR VALUE GAPS (FVG) - VAC√çOS DE LIQUIDEZ
    # =============================================================================

    def _detect_bullish_fvg(self) -> bool:
        """
        v8.0-CONFLUENCE: Detecta Fair Value Gap alcista (Bullish FVG)

        Un FVG alcista ocurre cuando:
        - Candle[i-2].high < Candle[i].low (hay un GAP entre velas)
        - Representa zona de liquidez no rellenada
        - El precio actual est√° retesteando esa zona (precio cerca del gap)

        Basado en investigaci√≥n profesional de ICT (Inner Circle Trader)

        Returns:
            True si detecta FVG alcista v√°lido y precio lo est√° retesteando
        """
        if len(self.candles) < self.fvg_lookback + 3:
            return False

        # Buscar FVG en las √∫ltimas velas
        for i in range(len(self.candles) - 3, max(len(self.candles) - self.fvg_lookback, 2), -1):
            # FVG alcista: high de vela[i-2] < low de vela[i]
            high_old = self.candles[i-2, 4]  # High de vela antigua
            low_new = self.candles[i, 3]      # Low de vela nueva

            # Hay un gap?
            if high_old < low_new:
                # Gap detectado: zona entre high_old y low_new
                gap_top = low_new
                gap_bottom = high_old
                gap_mid = (gap_top + gap_bottom) / 2
                gap_size_pct = ((gap_top - gap_bottom) / gap_bottom) * 100

                # Validar que el gap sea significativo (al menos 0.1%)
                if gap_size_pct < 0.1:
                    continue

                # Verificar si el precio actual est√° retesteando el FVG
                # (precio cerca de la zona del gap, dentro o ligeramente por debajo)
                price_to_gap_mid = abs(self.close - gap_mid) / gap_mid * 100

                # Si estamos dentro o cerca del gap (¬±0.5%)
                if price_to_gap_mid < 0.5 or (self.close >= gap_bottom and self.close <= gap_top):
                    return True

        return False

    def _detect_bearish_fvg(self) -> bool:
        """
        v8.0-CONFLUENCE: Detecta Fair Value Gap bajista (Bearish FVG)

        Un FVG bajista ocurre cuando:
        - Candle[i-2].low > Candle[i].high (hay un GAP entre velas)
        - Representa zona de liquidez no rellenada
        - El precio actual est√° retesteando esa zona (precio cerca del gap)

        Basado en investigaci√≥n profesional de ICT (Inner Circle Trader)

        Returns:
            True si detecta FVG bajista v√°lido y precio lo est√° retesteando
        """
        if len(self.candles) < self.fvg_lookback + 3:
            return False

        # Buscar FVG en las √∫ltimas velas
        for i in range(len(self.candles) - 3, max(len(self.candles) - self.fvg_lookback, 2), -1):
            # FVG bajista: low de vela[i-2] > high de vela[i]
            low_old = self.candles[i-2, 3]   # Low de vela antigua
            high_new = self.candles[i, 4]    # High de vela nueva

            # Hay un gap?
            if low_old > high_new:
                # Gap detectado: zona entre low_old y high_new
                gap_top = low_old
                gap_bottom = high_new
                gap_mid = (gap_top + gap_bottom) / 2
                gap_size_pct = ((gap_top - gap_bottom) / gap_bottom) * 100

                # Validar que el gap sea significativo (al menos 0.1%)
                if gap_size_pct < 0.1:
                    continue

                # Verificar si el precio actual est√° retesteando el FVG
                # (precio cerca de la zona del gap, dentro o ligeramente por encima)
                price_to_gap_mid = abs(self.close - gap_mid) / gap_mid * 100

                # Si estamos dentro o cerca del gap (¬±0.5%)
                if price_to_gap_mid < 0.5 or (self.close >= gap_bottom and self.close <= gap_top):
                    return True

        return False

    # =============================================================================
    # DETECCI√ìN DE DIVERGENCIAS
    # =============================================================================

    def _bullish_divergence(self) -> bool:
        """
        Detecci√≥n de divergencia alcista RSI vs Precio

        Divergencia alcista: Precio baja pero RSI sube (se√±al de reversi√≥n alcista)
        v5.2-FIXED-v3: Usa c√°lculo manual de RSI para evitar IndexError
        """
        if len(self.candles) < 60:
            return False

        # Calcular RSI manualmente para todas las velas
        close_prices = self.candles[:, 2]  # Columna close
        low_prices = self.candles[:, 3]    # Columna low

        # Usar c√°lculo manual de RSI que retorna array completo
        rsi_array = self._calculate_rsi_array(close_prices, self.rsi_period)

        # Buscar m√≠nimos en las √∫ltimas 40 velas (usando √≠ndices POSITIVOS)
        lookback = 40
        total_candles = len(self.candles)
        price_lows = []

        # Iterar desde el final hacia atr√°s usando √≠ndices positivos
        for i in range(total_candles - 5, max(total_candles - lookback, 5), -1):
            # Verificar si es un m√≠nimo local (comparar con 2 velas a cada lado)
            if (low_prices[i] <= low_prices[i-1] and
                low_prices[i] <= low_prices[i-2] and
                low_prices[i] <= low_prices[i+1] and
                low_prices[i] <= low_prices[i+2]):

                # Guardar: (√≠ndice, precio_low, valor_rsi)
                # rsi_array[i] ahora es un valor escalar v√°lido
                price_lows.append((i, low_prices[i], rsi_array[i]))

        # Necesitamos al menos 2 m√≠nimos
        if len(price_lows) < 2:
            return False

        # Buscar divergencia: precio m√°s reciente m√°s bajo PERO RSI m√°s alto
        # price_lows[0] es el m√°s reciente, price_lows[-1] el m√°s antiguo
        for j in range(len(price_lows) - 1):
            idx_recent, price_recent, rsi_recent = price_lows[j]

            for k in range(j + 1, len(price_lows)):
                idx_old, price_old, rsi_old = price_lows[k]

                # Divergencia alcista: precio baja, RSI sube
                if price_recent < price_old and rsi_recent > rsi_old:
                    price_diff_pct = abs((price_recent - price_old) / price_old) * 100
                    rsi_diff = abs(rsi_recent - rsi_old)

                    # v5.5-CONSERVATIVE: Divergencia M√ÅS ESTRICTA: 0.5% precio + 5 puntos RSI
                    if price_diff_pct >= 0.5 and rsi_diff >= 5:
                        return True

        return False

    def _bearish_divergence(self) -> bool:
        """
        Detecci√≥n de divergencia bajista RSI vs Precio

        Divergencia bajista: Precio sube pero RSI baja (se√±al de reversi√≥n bajista)
        v5.2-FIXED-v3: Usa c√°lculo manual de RSI para evitar IndexError
        """
        if len(self.candles) < 60:
            return False

        # Calcular RSI manualmente para todas las velas
        close_prices = self.candles[:, 2]  # Columna close
        high_prices = self.candles[:, 2]    # Columna high (usar close en vez de high para consistencia)

        # Usar c√°lculo manual de RSI que retorna array completo
        rsi_array = self._calculate_rsi_array(close_prices, self.rsi_period)

        # Buscar m√°ximos en las √∫ltimas 40 velas (usando √≠ndices POSITIVOS)
        lookback = 40
        total_candles = len(self.candles)
        price_highs = []

        # Iterar desde el final hacia atr√°s usando √≠ndices positivos
        for i in range(total_candles - 5, max(total_candles - lookback, 5), -1):
            # Verificar si es un m√°ximo local (comparar con 2 velas a cada lado)
            if (high_prices[i] >= high_prices[i-1] and
                high_prices[i] >= high_prices[i-2] and
                high_prices[i] >= high_prices[i+1] and
                high_prices[i] >= high_prices[i+2]):

                # Guardar: (√≠ndice, precio_high, valor_rsi)
                # rsi_array[i] ahora es un valor escalar v√°lido
                price_highs.append((i, high_prices[i], rsi_array[i]))

        # Necesitamos al menos 2 m√°ximos
        if len(price_highs) < 2:
            return False

        # Buscar divergencia: precio m√°s reciente m√°s alto PERO RSI m√°s bajo
        # price_highs[0] es el m√°s reciente, price_highs[-1] el m√°s antiguo
        for j in range(len(price_highs) - 1):
            idx_recent, price_recent, rsi_recent = price_highs[j]

            for k in range(j + 1, len(price_highs)):
                idx_old, price_old, rsi_old = price_highs[k]

                # Divergencia bajista: precio sube, RSI baja
                if price_recent > price_old and rsi_recent < rsi_old:
                    price_diff_pct = abs((price_recent - price_old) / price_old) * 100
                    rsi_diff = abs(rsi_recent - rsi_old)

                    # v5.5-CONSERVATIVE: Divergencia M√ÅS ESTRICTA: 0.5% precio + 5 puntos RSI
                    if price_diff_pct >= 0.5 and rsi_diff >= 5:
                        return True

        return False

    def _bullish_divergence_1h(self, candles_1h) -> bool:
        """
        v6.1-BALANCED: Detecci√≥n de divergencia alcista en 1H M√ÅS PERMISIVA

        Umbrales RELAJADOS para capturar m√°s divergencias v√°lidas:
        - Lookback: 60 velas (amplio)
        - Threshold: 0.2% precio (era 0.3%) + 2 puntos RSI (era 3)
        - Confirmaci√≥n: M√≠nimos locales comparados con vecinos

        Args:
            candles_1h: Array de velas 1H

        Returns:
            True si se detecta divergencia alcista
        """
        if len(candles_1h) < 100:
            return False

        close_prices = candles_1h[:, 2]
        low_prices = candles_1h[:, 3]

        # Calcular RSI para 1H
        rsi_array = self._calculate_rsi_array(close_prices, self.rsi_period)

        # Buscar m√≠nimos en las √∫ltimas 60 velas
        lookback = 60
        total_candles = len(candles_1h)
        price_lows = []

        for i in range(total_candles - 5, max(total_candles - lookback, 5), -1):
            # M√≠nimo local (comparar con 2 velas a cada lado)
            if (low_prices[i] <= low_prices[i-1] and
                low_prices[i] <= low_prices[i-2] and
                low_prices[i] <= low_prices[i+1] and
                low_prices[i] <= low_prices[i+2]):

                price_lows.append((i, low_prices[i], rsi_array[i]))

        if len(price_lows) < 2:
            return False

        # Buscar divergencia alcista: precio baja, RSI sube
        for j in range(len(price_lows) - 1):
            idx_recent, price_recent, rsi_recent = price_lows[j]

            for k in range(j + 1, len(price_lows)):
                idx_old, price_old, rsi_old = price_lows[k]

                # Divergencia alcista
                if price_recent < price_old and rsi_recent > rsi_old:
                    price_diff_pct = abs((price_recent - price_old) / price_old) * 100
                    rsi_diff = abs(rsi_recent - rsi_old)

                    # v6.1-BALANCED: Umbrales M√ÅS PERMISIVOS (0.2% precio + 2 RSI)
                    if price_diff_pct >= 0.2 and rsi_diff >= 2:
                        return True

        return False

    def _bearish_divergence_1h(self, candles_1h) -> bool:
        """
        v6.1-BALANCED: Detecci√≥n de divergencia bajista en 1H M√ÅS PERMISIVA

        Umbrales RELAJADOS para capturar m√°s divergencias v√°lidas:
        - Lookback: 60 velas (amplio)
        - Threshold: 0.2% precio (era 0.3%) + 2 puntos RSI (era 3)
        - Confirmaci√≥n: M√°ximos locales comparados con vecinos

        Args:
            candles_1h: Array de velas 1H

        Returns:
            True si se detecta divergencia bajista
        """
        if len(candles_1h) < 100:
            return False

        close_prices = candles_1h[:, 2]
        high_prices = candles_1h[:, 2]  # Usar close para consistencia

        # Calcular RSI para 1H
        rsi_array = self._calculate_rsi_array(close_prices, self.rsi_period)

        # Buscar m√°ximos en las √∫ltimas 60 velas
        lookback = 60
        total_candles = len(candles_1h)
        price_highs = []

        for i in range(total_candles - 5, max(total_candles - lookback, 5), -1):
            # M√°ximo local (comparar con 2 velas a cada lado)
            if (high_prices[i] >= high_prices[i-1] and
                high_prices[i] >= high_prices[i-2] and
                high_prices[i] >= high_prices[i+1] and
                high_prices[i] >= high_prices[i+2]):

                price_highs.append((i, high_prices[i], rsi_array[i]))

        if len(price_highs) < 2:
            return False

        # Buscar divergencia bajista: precio sube, RSI baja
        for j in range(len(price_highs) - 1):
            idx_recent, price_recent, rsi_recent = price_highs[j]

            for k in range(j + 1, len(price_highs)):
                idx_old, price_old, rsi_old = price_highs[k]

                # Divergencia bajista
                if price_recent > price_old and rsi_recent < rsi_old:
                    price_diff_pct = abs((price_recent - price_old) / price_old) * 100
                    rsi_diff = abs(rsi_recent - rsi_old)

                    # v6.1-BALANCED: Umbrales M√ÅS PERMISIVOS (0.2% precio + 2 RSI)
                    if price_diff_pct >= 0.2 and rsi_diff >= 2:
                        return True

        return False

    # =============================================================================
    # GESTI√ìN DE RIESGO
    # =============================================================================

    def _calculate_position_size(self, stop_distance):
        """
        Calcula tama√±o de posici√≥n para riesgo del 1.5% con apalancamiento 20x

        Con leverage:
        - Capital disponible = balance * leverage
        - Pero el riesgo sigue siendo 1.5% del balance (sin apalancar)
        - Esto permite abrir posiciones m√°s grandes manteniendo el riesgo controlado
        """
        # Riesgo en $ basado en balance real (sin apalancamiento)
        risk_amount = self.balance * (self.risk_percent / 100)

        # Tama√±o de posici√≥n basado en stop distance
        # position_value = cu√°nto $ queremos arriesgar / (stop_distance como % del precio)
        position_value = risk_amount / (stop_distance / self.close)

        # Con leverage 20x, podemos abrir posiciones hasta 20x nuestro capital
        # Limitar a 90% del capital apalancado disponible
        max_position_value = self.balance * self.leverage * 0.9
        position_value = min(position_value, max_position_value)

        # Convertir valor de posici√≥n a cantidad de BTC
        qty = position_value / self.close

        return round(qty, 6)  # 6 decimales para precisi√≥n